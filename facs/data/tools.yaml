sleuthkit:
  ref: 'http://wiki.sleuthkit.org/index.php?title=The_Sleuth_Kit'
  cheat_sheet:
    - description: 'tools working on the physical media layer'
      note: 'lshw, lsscsi, hdparm, sdparm, dd, dc3dd, ddrescue'
    - description: 'tsk commands working in the media management layer'
      note: 'mm* like mmls (other non tsk: fdisk, losetup)'
    - description: 'tsk commands working on the file system layer'
      note: 'fs* like fsstat (other non tsk: mount, file -s)'
    - description: 'tsk commands working on the file name layer'
      note: 'f* like fls/ffind (other non tsk: find, ls)'
    - description: 'tsk commands working on the application layer (meta and content)'
      note: 'i* for metadata like icat (non tsk: exiftool, file), blk* for content like blkls (non ts: grep)'
    - description: 'list disk partitions (offset unit is sector)'
      note: 'mmls disk.raw'
    - description: 'describe a partition (file system, ...)'
      note: 'fsstat -o <partition sector offset> disk.raw'
    - description: 'list all allocated files on a partition'
      note: "fls -Frpu -m '/' -o <partition sector offset> disk.raw | tee fls_files_disk.body"
    - description: 'list all deleted files on a partition'
      note: "fls -Frpd -m '/' -o <partition sector offset> disk.raw | tee fls_files_deleted_disk.body"
    - description: 'list all deleted folders on a partition'
      note: "fls -Drpd -m '/' -o <partition sector offset> disk.raw | tee fls_folders_deleted_disk.body"
    - description: 'list filenames related to an inode'
      note: 'ffind -o <partition sector offset> -a disk.raw <inode>'
    - description: 'get inode details (mactimes, data blocks'
      note: 'istat -o <partition sector offset> disk.raw <inode>'
    - description: 'carve a file at a given inode'
      note: 'icat -o <partition sector offset> disk.raw <inode> > file.dat'
    - description: 'retrieve inode associated to a data block'
      note: 'ifind -o <partition sector offset> -d <data block> disk.raw'
    - description: 'carve data blocks'
      note: 'blkcat -o <partition sector offset> disk.raw <data block> <nb blocks> > block.dat'
    - description: 'carve unallocated data blocks'
      note: 'blkls -o <partition sector offset> disk.raw > unallocated.dat'
    - description: 'carve slack space'
      note: 'blkls -o <partition sector offset> -s disk.raw > slack.dat'
    - description: 'from grep to data block'
      note: 'grep -abi to get byte offset X of hit, fdisk to get partition offset Y the hit X/sector size belongs to, get data blocks with fsstat on (X-Y*sector byte size)/block size, carve with icat/ifind/blkcat'
    - description: 'fls output, body file format'
      note: 'MD5|name|inode|mode_as_string|UID|GID|size|atime|mtime|ctime|crtime'
    - description: 'fls output, mode_as_string meaning'
      note: 'X/Y where X comes from file name layer, and Y from the metadata layer'
    - description: 'fls output, mode_as_string for allocated file'
      note: 'X = Y'
    - description: 'fls output, mode_as_string markers'
      note: 'r=regular file, d=directory, l=symbolic link, -=unknown, V=virtual inode created by tsk (eg. orphan file)'
    - description: 'fls output, mode_as_string tag orphan file'
      note: 'unallocated meta data, no corresponding file name, can only be accessed using metadata layer'
    - description: 'fls outpout, mode_as_string tag realloc'
      note: 'metadata allocated but not file name layer. either file deleted (inode points to a new file), or renamed (inode points to the correct file name)'
    - description: 'fls output, mode_as_string tag *'
      note: 'indicates an unallocated or deleted entry'

plaso:
  ref: 'https://plaso.readthedocs.io/en/latest/'
  cheat_sheet:
    - description: 'docker preparation, as it conflicts with ewf-tools'
      note: 'mkdir -p docker_plaso_tools && cd docker_plaso_tools'
    - description: 'docker preparation, as it conflicts with ewf-tools'
      note: 'curl ''https://raw.githubusercontent.com/log2timeline/plaso/main/config/docker/Dockerfile'' -o Dockerfile'
    - description: 'docker preparation, as it conflicts with ewf-tools'
      note: 'curl  ''https://raw.githubusercontent.com/log2timeline/plaso/main/config/docker/plaso-switch.sh'' -o plaso-switch.sh'
    - description: 'docker preparation/update, as it conflicts with ewf-tools'
      note: 'docker build -t plaso-tools .'
    - description: 'base syntax to use the docker image'
      note: 'docker run -it --rm -u $(id -u $USER):$(id -g $USER) -v $PWD/<artifacts folder>:/data_src:ro -v $PWD/<result folder>:/data_dst plaso-tools'
    - description: 'base options to use for log2timeline/psort'
      note: '--status-view linear --logfile /data_dst/{l2t,psort}.log.gz --debug (worker logs)'
    - description: 'base options to use with log2timeline --no_vss/--only_vss/--vss_store N1,N2'
      note: '--process_archives (disabled by default)'
    - description: 'psort output format to use'
      note: 'json_line or elastic (w/ --index_name --server --port --elastic_mappings)'
    - description: 'keep trace of options used in a log2timeline execution'
      note: 'pinfo -v --output_format text -w pinfo_l2t.txt l2t.plaso'
    - description: 'meaning of some parsers'
      note: 'msiecf (IE), czip (office files), bencode (torrent)'
    - description: 'using artifacts definitions instead of parsers'
      note: '--artifact_definitions <path to the clone of https://github.com/ForensicArtifacts/artifacts>'
    - description: 'using your own presets'
      note: '--data <path to your own presets.yaml>'

volatility2:
  ref: 'https://github.com/volatilityfoundation/volatility'
  cheat_sheet:
    - description: '.volatilityrc after imageinfo (list of profiles with --info)'
      note: 'vol.py --conf-file .volatilityrc <plugin> <options>'
    - description: 'check if a file is on the disk'
      note: 'mftparser | grep <pattern>'
    - description: 'get physical offset of file loaded in memory'
      note: 'plugin filescan, then grep on the filename'
    - description: 'dump file from memory'
      note: 'plugin dumpfile -Q 0x<physical offset> -S summary.txt -D outdir -u -n'

tshark:
  ref: 'https://www.wireshark.org/docs/dfref/'
  cheat_sheet:
    - description: 'list protocols in a capture'
      note: 'tshark -r capture.pcap -T fields -e _ws.col.Protocol | sort | uniq -c'
    - description: 'list IPs in a capture'
      note: 'tshark -r capture.pcap -qz ip_hosts,tree'
    - description: 'list src/dest in a capture'
      note: 'tshark -r capture.pcap -T fields -e ip.src -e ip.dst | sort | uniq -c'
    - description: 'dump data of a TCP session'
      note: 'tshark -r capture.pcap -Y "tcp.stream == X" -T fields -e data'
    - description: 'list HTTP requests in a capture'
      note: 'tshark -r capture.pcap -Y "http.request" -T fields -e "ip.src" -e "ip.dst" -e "http.host" -e "http.server" -e "http.request.full_uri" -e "http.referer" -e "http.response.code" -e "http.content_type" -e "http.location" -E header=y -E separator=, -E quote=d'

yara:
  ref: 'https://github.com/Yara-Rules/rules'
  cheat_sheet:
    - description: 'other sources of rules'
      note: 'https://github.com/InQuest/awesome-yara'
    - description: 'assemble a ruleset'
      note: 'create a ruleset.yar file with series to include (MALW, RANSOM, RAT, TOOLKIT from the repo)'
    - description: 'run yara against a mounted disk'
      note: 'yara -r ruleset.yara <mount point>'

nsrl:
  ref: 'https://www.nist.gov/itl/ssd/software-quality-group/national-software-reference-library-nsrl/nsrl-download/current-rds (updated every 3 months, known goods+bads)'
  cheat_sheet:
    - description: 'download dataset for legacy and modern applications'
      note: 'curl "https://s3.amazonaws.com/rds.nsrl.nist.gov/RDS/current/RDS_{legacy, modern}.iso" -o {legacy,modern}.iso'
    - description: 'download integrity hash of the datasets'
      note: 'curl "https://s3.amazonaws.com/rds.nsrl.nist.gov/RDS/current/version.txt" -o nsrl_sha1.txt'
    - description: 'verify data sets integrity (example on legacy)'
      note: 'cat nsrl_sha1.txt | grep "legacy" | cut -d, -f1 | tr -d ''"'' | xargs -I {} echo "{} legacy.iso" | sha1sum --check'
    - description: 'mount the iso'
      note: 'mkdir legacy && sudo mount legacy.iso legacy/'

bulk_extractor:
  ref: 'https://github.com/simsong/bulk_extractor'
  cheat_sheet:
    - description: 'usage (-x to exclude, -e to include enable, -E to exclude all but one)'
      note: 'bulk_extractor  -E <scanner1> -e <scanner2> -f <string/regex> -o output/ disk.raw'
    - description: 'outputs'
      note: '1 txt file per scanner (+ histogram sometimes), offset of hits (convert to data block with icat/ifind)'

misc:
  - description: 'convert base 16 to base 10'
    note: 'echo "ibase=16;DEADBEEF" | bc'
  - description: 'compute all hashes in a folder'
    note: 'find . -type f -exec sha256sum {} \; > ../sha256_all_files.txt'
  - description: 'compare integrity of files with a witness file'
    note: 'sha1sum -c hash.txt --ignore-missing'
  - description: 'change the entrypoint to enter in a docker container'
    note: 'docker run -it --rm --entrypoint bash <image>'
  - description: 'search strings in raw image'
    note: 'grep -abi <pattern> disk.raw'
  - description: 'hexdump at an specific offset'
    note: 'xxd -s <byte offset> disk.raw | head'
  - description: 'list Windows events with a description'
    note: '(Get-Winevent -ListProvider *).Events | Select-Object -Propert Id, Description'
  - description: 'parse a prefetch (libscca-utils)'
    note: 'sccainfo file.pf'
  - description: 'convert date to unix epoch timestamp'
    note: 'date -u +%s'
  - description: 'convert unix epoch timestamp to date'
    note: 'date -d @<timestamp>'
  - description: 'print lines between 2 patterns, pattern included'
    note: 'sed -n ''/pattern1/,/pattern2/p'''
  - description: 'print lines between 2 patterns, pattern included'
    note: 'awk ''/pattern1/{get=1; next} /pattern2/{get=0} get'''
  - description: 'convert hexa string to binary'
    note: 'echo "deadbeef" | xxd -p -r > string.bin'
  - description: 'dump hexa from offset X for N bytes'
    note: 'xxd -p -s X -l N file.bin'
  - description: 'filter json for elements in list key'
    note: 'jq ''select(.tags as $tags | ["item1", "item2"] | map([$tags[] == .] | any) | any)'''
  - description: 'tcpdump traffic from and to one host'
    note: 'tcpdump -i wlo1 -w capture.pcap host a.b.c.d'
